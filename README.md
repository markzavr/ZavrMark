## Первая Лаба 


 1. image = "/labs/cat.png"
  Эта строка определяет путь к изображению. Переменная image содержит строку с местоположением файла (cat.png), который находится в папке /labs.

 2. img_bgr = cv2.imread()
    
    Используется функция cv2.imread из библиотеки OpenCV для чтения изображения по указанному пути.
    cv2.imread возвращает изображение в формате массива NumPy, где каждый элемент соответствует пикселю.
    По умолчанию OpenCV загружает изображение в цветовом формате BGR (синий, зеленый, красный).
    Результат сохраняется в переменной img_bgr.


 3. image_dimmed = (img_bgr / 3).astype(np.uint8)
    
     Эта строка затемняет изображение, разделяя значения каждого пикселя на 3.
     (img_bgr / 3) уменьшает интенсивность цвета каждого канала (B, G, R).
     .astype(np.uint8) приводит результат к типу uint8 (целые числа от 0 до 255), который требуется для изображений.
     cv2_imshow(image_dimmed)
     Используется функция cv2_imshow для отображения обработанного изображения в среде, например, Google Colab.
     Она показывает изображение image_dimmed в отдельном окне или внутри среды.


 4. img_bgr2hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
    
    Здесь используется функция cv2.cvtColor для преобразования изображения из цветового пространства BGR (синий, зеленый, красный) в HSV (оттенок, насыщенность, яркость).
    Цветовое пространство HSV часто используется в обработке изображений, поскольку оно отделяет цвет (Hue) от яркости (Value), что упрощает задачи, такие как выделение цветов.
 
 6. cv2_imshow(img_bgr2hsv)
 • Показывает преобразованное изображение в формате HSV.
 • Однако важно отметить, что в HSV-формате изображение может отображаться некорректно, поскольку оно рассчитано на внутреннее использование в обработке, а не для визуализации.


 7. img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
 
     Конвертирует изображение из формата BGR в RGB. OpenCV по умолчанию использует формат BGR, а для корректной визуализации в большинстве библиотек (например, Matplotlib) нужен формат RGB.
 
 8. img_rgb2hsv = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)
 
     Конвертирует изображение из формата RGB в HSV. HSV (Hue, Saturation, Value) позволяет легче работать с цветами, выделяя их оттенок (Hue), насыщенность (Saturation) и яркость (Value).
 9. print(f"Размер: {img_bgr.shape}")
  
    Выводит размер изображения в формате (высота, ширина, количество каналов). Это полезно для проверки размеров.
 10. h, s, v = img_rgb2hsv[70, 70]

     Извлекает значения оттенка (h), насыщенности (s) и яркости (v) для пикселя в координатах (70, 70) из изображения в формате HSV.



 *Преобразование в формат с плавающей запятой*

 1. img_rgb_float = img_rgb / 255.0
 • Нормализует RGB-значения изображения в диапазон [0, 1].
 2. r, g, b = img_rgb_float[:, :, 0], img_rgb_float[:, :, 1], img_rgb_float[:, :, 2]
 • Разделяет нормализованное изображение на три компонента: r (красный), g (зеленый) и b (синий).

*Вычисление компонентов HSV*

 3. v = np.max(img_rgb_float, axis=2)
 • Определяет максимальное значение интенсивности (яркость, v) для каждого пикселя.
 4. min = np.min(img_rgb_float, axis=2)
 • Определяет минимальное значение интенсивности для каждого пикселя.
 5. s = np.where(v == 0, 0, (v - min) / v)
 • Вычисляет насыщенность (s) как разницу между максимальной и минимальной интенсивностью, деленную на v.
 • Если v = 0, насыщенность устанавливается в 0, чтобы избежать деления на ноль.
 6. h = np.zeros_like(r)
 • Создает массив h (оттенок) такой же формы, как канал r, заполненный нулями.

*Определение масок для цвета*

 7. mask_r = v == r
 • Создает логическую маску для пикселей, где максимальная интенсивность соответствует красному каналу.
 8. mask_g = v == g
 • Аналогично, для зеленого канала.
 9. mask_b = v == b
 • Аналогично, для синего канала.

*Вычисление оттенка (Hue)*

 10. h[mask_r] = 60 * (g[mask_r] - b[mask_r]) / (v[mask_r] - min[mask_r])
 • Вычисляет оттенок для пикселей, где красный доминирует. Формула основана на разнице между зелеными и синими значениями.
 11. h[mask_g] = 120 + 60 * (b[mask_g] - r[mask_g]) / (v[mask_g] - min[mask_g])
 • Вычисляет оттенок для пикселей, где зеленый доминирует.
 12. h[mask_b] = 240 + 60 * (r[mask_b] - g[mask_b]) / (v[mask_b] - min[mask_b])
 • Вычисляет оттенок для пикселей, где синий доминирует.
 13. h = np.where(h < 0, h + 360, h)
 • Если оттенок отрицательный, добавляется 360 градусов.
 14. h = h / 2
 • Приводит оттенок в диапазон [0, 180], используемый в OpenCV.

*Конвертация насыщенности и яркости*

 15. s = 255 * s
 • Масштабирует насыщенность в диапазон [0, 255].
 16. v = 255 * v
 • Масштабирует яркость в диапазон [0, 255].

*Создание HSV-изображения*

 17. hsv_arr = np.stack([h, s, v], axis=-1).astype(np.uint8)
 • Объединяет компоненты h, s и v в одно изображение в формате HSV с целыми числами (uint8).
 18. cv2_imshow(hsv_arr)
 • Отображает преобразованное изображение.

*Анализ пикселя*

 19. h, s, v = hsv_arr[70, 70]
 • Извлекает значения оттенка (h), насыщенности (s) и яркости (v) для пикселя в координате (70, 70).
 20. print(f"H: {h}, S: {s}, V: {v}")
 • Выводит значения H, S и V для заданного пикселя.

   
