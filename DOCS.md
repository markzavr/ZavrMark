# Первая Лаба 

 ## img_bgr = cv2.imread()
    
   Используется функция cv2.imread из библиотеки OpenCV для чтения изображения по указанному пути.
    cv2.imread возвращает изображение в формате массива NumPy, где каждый элемент соответствует пикселю.
    По умолчанию OpenCV загружает изображение в цветовом формате BGR (синий, зеленый, красный).
    Результат сохраняется в переменной img_bgr.


 ## image_dimmed = (img_bgr / 3).astype(np.uint8)
    
   Эта строка затемняет изображение, разделяя значения каждого пикселя на 3.
     (img_bgr / 3) уменьшает интенсивность цвета каждого канала (B, G, R).
     .astype(np.uint8) приводит результат к типу uint8 (целые числа от 0 до 255), который требуется для изображений.
     cv2_imshow(image_dimmed)
     Используется функция cv2_imshow для отображения обработанного изображения в среде, например, Google Colab.
     Она показывает изображение image_dimmed в отдельном окне или внутри среды.


 ## img_bgr2hsv = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2HSV)
    
   Здесь используется функция cv2.cvtColor для преобразования изображения из цветового пространства BGR (синий, зеленый, красный) в HSV (оттенок, насыщенность, яркость).
    Цветовое пространство HSV часто используется в обработке изображений, поскольку оно отделяет цвет (Hue) от яркости (Value), что упрощает задачи, такие как выделение цветов.
 
 ## cv2_imshow(img_bgr2hsv)
 • Показывает преобразованное изображение в формате HSV.
 
 • Однако важно отметить, что в HSV-формате изображение может отображаться некорректно, поскольку оно рассчитано на внутреннее использование в обработке, а не для визуализации.


 ## img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
 
   Конвертирует изображение из формата BGR в RGB. OpenCV по умолчанию использует формат BGR, а для корректной визуализации в большинстве библиотек (например, Matplotlib) нужен формат RGB.
 
 ## img_rgb2hsv = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)
 
   Конвертирует изображение из формата RGB в HSV. HSV (Hue, Saturation, Value) позволяет легче работать с цветами, выделяя их оттенок (Hue), насыщенность (Saturation) и яркость (Value).
 # print(f"Размер: {img_bgr.shape}")
  
   Выводит размер изображения в формате (высота, ширина, количество каналов). Это полезно для проверки размеров.
 ## h, s, v = img_rgb2hsv[70, 70]

 Извлекает значения оттенка (h), насыщенности (s) и яркости (v) для пикселя в координатах (70, 70) из изображения в формате HSV.



 ## Преобразование в формат с плавающей запятой

 1. img_rgb_float = img_rgb / 255.0
 • Нормализует RGB-значения изображения в диапазон [0, 1].
 2. r, g, b = img_rgb_float[:, :, 0], img_rgb_float[:, :, 1], img_rgb_float[:, :, 2]
 • Разделяет нормализованное изображение на три компонента: r (красный), g (зеленый) и b (синий).

## Вычисление компонентов HSV

 3. v = np.max(img_rgb_float, axis=2)
 • Определяет максимальное значение интенсивности (яркость, v) для каждого пикселя.
 4. min = np.min(img_rgb_float, axis=2)
 • Определяет минимальное значение интенсивности для каждого пикселя.
 5. s = np.where(v == 0, 0, (v - min) / v)
 • Вычисляет насыщенность (s) как разницу между максимальной и минимальной интенсивностью, деленную на v.
 • Если v = 0, насыщенность устанавливается в 0, чтобы избежать деления на ноль.
 6. h = np.zeros_like(r)
 • Создает массив h (оттенок) такой же формы, как канал r, заполненный нулями.

## Определение масок для цвета

 7. mask_r = v == r
 • Создает логическую маску для пикселей, где максимальная интенсивность соответствует красному каналу.
 8. mask_g = v == g
 • Аналогично, для зеленого канала.
 9. mask_b = v == b
 • Аналогично, для синего канала.

## Вычисление оттенка (Hue)

 10. h[mask_r] = 60 * (g[mask_r] - b[mask_r]) / (v[mask_r] - min[mask_r])
 • Вычисляет оттенок для пикселей, где красный доминирует. Формула основана на разнице между зелеными и синими значениями.
 11. h[mask_g] = 120 + 60 * (b[mask_g] - r[mask_g]) / (v[mask_g] - min[mask_g])
 • Вычисляет оттенок для пикселей, где зеленый доминирует.
 12. h[mask_b] = 240 + 60 * (r[mask_b] - g[mask_b]) / (v[mask_b] - min[mask_b])
 • Вычисляет оттенок для пикселей, где синий доминирует.
 13. h = np.where(h < 0, h + 360, h)
 • Если оттенок отрицательный, добавляется 360 градусов.
 14. h = h / 2
 • Приводит оттенок в диапазон [0, 180], используемый в OpenCV.

## Конвертация насыщенности и яркости

 15. s = 255 * s
 • Масштабирует насыщенность в диапазон [0, 255].
 16. v = 255 * v
 • Масштабирует яркость в диапазон [0, 255].

## Создание HSV-изображения

 17. hsv_arr = np.stack([h, s, v], axis=-1).astype(np.uint8)
 • Объединяет компоненты h, s и v в одно изображение в формате HSV с целыми числами (uint8).
 18. cv2_imshow(hsv_arr)
 • Отображает преобразованное изображение.

## Анализ пикселя

 19. h, s, v = hsv_arr[70, 70]
 • Извлекает значения оттенка (h), насыщенности (s) и яркости (v) для пикселя в координате (70, 70).
 20. print(f"H: {h}, S: {s}, V: {v}")
 • Выводит значения H, S и V для заданного пикселя.

# Вторая Лаба

## image = cv2.imread()
   
   • Загружает изображение с указанного пути в формате BGR (по умолчанию OpenCV).
   
## image_inter_area = cv2.resize(image, (0, 0), fx=3, fy=3, interpolation=cv2.INTER_AREA)
 
   • Масштабирует изображение, увеличивая его размер в 3 раза по горизонтали (fx=3) и вертикали (fy=3).
 
   • Используется метод интерполяции cv2.INTER_AREA, подходящий для уменьшения или высокого качества увеличения.

## print(image_inter_area[55][55])
 
   • Выводит значение пикселя на позиции (55, 55) в увеличенном изображении.
 
   • Значение пикселя — массив [B, G, R], где B — синий, G — зеленый, R — красный компоненты.

## resize_k_x = 3 и resize_k_y = 3
 
   • Указывают коэффициенты масштабирования по горизонтали и вертикали (увеличение в 3 раза).
 
## blank_image = np.zeros((image.shape[0] * resize_k_x, image.shape[1] * resize_k_y, image.shape[2]), np.uint8)
 
   • Создает пустое изображение (blank_image) с увеличенными размерами (в 3 раза по обеим осям) и тем же количеством каналов.
 
   • Используется np.zeros для заполнения массива нулями (черный фон).
 
## Двойной цикл по строкам и столбцам:

       for row in range(image.shape[0]): 
           for col in range(image.shape[1]):

   • Проходит по всем пикселям оригинального изображения.

 
## blank_image[row*resize_k_x][col*resize_k_y] = image[row][col]
 
   • Устанавливает цвет пикселя из исходного изображения в соответствующую позицию увеличенного.
 
## Вложенный цикл:

       for res_row in range(resize_k_x): 
           for res_col in range(resize_k_y):
               blank_image[row*resize_k_x + res_row][col*resize_k_y + res_col] = image[row][col]

   • Заполняет все пиксели вокруг основной точки, дублируя цвет исходного пикселя для масштабирования.

 
## **Основная идея:**

Код вручную масштабирует изображение путем дублирования пикселей, создавая эффект увеличения. Полученное изображение сравнивается с масштабированным изображением, созданным функцией OpenCV.

## image_lin_intr = cv2.imread()
    
   • Загружает изображение с указанного пути в формате BGR.  
 
## image_lin_intr = cv2.resize(image_lin_intr, (0, 0), fx=3, fy=3, interpolation=cv2.INTER_LINEAR)
 
   • Масштабирует изображение в 3 раза по горизонтали и вертикали с использованием интерполяции cv2.INTER_LINEAR. Этот метод применяется для более плавных изменений размера, что может создавать более качественные результаты по сравнению с cv2.INTER_AREA.

**Метод cv2.INTER_LINEAR использует линейную интерполяцию для вычисления новых пикселей, что делает изображение более четким по сравнению с cv2.INTER_AREA**

**Установка коэффициентов масштабирования**
koef_x = 3
koef_y = 3

## Извлечение размеров изображения

height, width = image.shape[:2]

## Рассчет нового размера изображения

new_height = int(height * koef_y)

new_width = int(width * koef_x)

**Создание пустого массива для результата**

result = np.zeros((new_height, new_width, image.shape[2]), dtype=image.dtype)

## Циклы для каждого пикселя результата

    for y in range(new_height):
        for x in range(new_width):
            original_y = y / koef_y
            original_x = x / koef_x

        y_low = math.floor(original_y)
        x_low = math.floor(original_x)

        y_frac = original_y - y_low
        x_frac = original_x - x_low

        # Ограничение координат для соседей пикселя
        y_low = max(0, min(y_low, height - 2))
        x_low = max(0, min(x_low, width - 2))

        y_high = min(height - 1, y_low + 1)
        x_high = min(width - 1, x_low + 1)

        # Билинейная интерполяция
        for c in range(image.shape[2]):
            val_low = image[y_low, x_low, c]
            val_high = image[y_high, x_low, c]
            val_low2 = image[y_low, x_high, c]
            val_high2 = image[y_high, x_high, c]

            result[y, x, c] = (1 - y_frac) * (1 - x_frac) * val_low + (y_frac) * (1 - x_frac) * val_high + (1 - y_frac) * (x_frac) * val_low2 + (y_frac) * (x_frac) * val_high2




